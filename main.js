/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AndroidPdfPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var AndroidPdfPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    /**
     * specialized CSS styles for the exported HTML.
     * Includes print-media queries to ensure better output.
     */
    this.styles = `
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            color: #000;
            background: #fff;
            padding: 20px;
            line-height: 1.6;
            font-size: 14px;
            max-width: 800px;
            margin: 0 auto;
        }
        img { max-width: 100%; height: auto; display: block; margin: 10px 0; }
        h1, h2, h3, h4, h5, h6 { margin-top: 1.5em; margin-bottom: 0.5em; page-break-after: avoid; }
        blockquote { border-left: 4px solid #ccc; padding-left: 10px; color: #666; }
        code { background: #f4f4f4; padding: 2px 5px; border-radius: 3px; font-family: monospace; }
        pre { background: #f4f4f4; padding: 10px; border-radius: 5px; overflow-x: auto; }
        table { border-collapse: collapse; width: 100%; margin: 15px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        a { color: #007bff; text-decoration: none; }
        /* Print-specific overrides */
        @media print {
            body { 
                padding: 0; 
                margin: 0; 
                -webkit-print-color-adjust: exact; 
                print-color-adjust: exact; 
            }
            a { text-decoration: none; color: black; }
            .print-hidden { display: none; }
        }
    </style>
    `;
  }
  /**
   * Plugin entry point.
   */
  async onload() {
    this.addRibbonIcon("pdf-file", "Export to PDF", () => {
      this.generatePdf();
    });
    this.addCommand({
      id: "export-android-pdf",
      name: "Export current file to PDF",
      callback: () => this.generatePdf()
    });
  }
  /**
   * Main orchestration function.
   * 
   * Steps:
   * 1. Get Active File.
   * 2. Render Markdown to DOM.
   * 3. Process/Embed Images.
   * 4. Wrap in HTML Template.
   * 5. Save to File system.
   * 6. Open Modal.
   */
  async generatePdf() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian.Notice("No active file selected.");
      return;
    }
    if (false) console.log(`[AndroidPdf] Starting export for ${activeFile.path}`);
    new import_obsidian.Notice(`Generating HTML for printing...`);
    const tempContainer = document.body.createDiv("print-temp-container");
    tempContainer.style.display = "none";
    try {
      await this.renderMarkdown(activeFile, tempContainer);
      const exportFolder = await this.createUniqueExportFolder(activeFile.basename);
      await this.processImages(tempContainer);
      this.sanitizeElements(tempContainer);
      const fullHtml = this.generateHtmlTemplate(activeFile.basename, tempContainer.innerHTML);
      await this.saveAndPrompt(activeFile.basename, exportFolder, fullHtml);
    } catch (e) {
      console.error("[AndroidPdf] Export failed", e);
      new import_obsidian.Notice("PDF Export failed. Check console for details.");
    } finally {
      document.body.removeChild(tempContainer);
    }
  }
  /**
   * Renders markdown content into an HTML container.
   */
  async renderMarkdown(file, container) {
    if (false) console.log("[AndroidPdf] Rendering markdown...");
    const content = await this.app.vault.read(file);
    await import_obsidian.MarkdownRenderer.render(
      this.app,
      content,
      container,
      file.path,
      new import_obsidian.Component()
    );
  }
  /**
   * Creates a unique folder for the export to avoid collisions.
   */
  async createUniqueExportFolder(basename) {
    const safeBasename = basename.replace(/[^a-z0-9]/gi, "_");
    let folderName = `${safeBasename}-Export`;
    if (!await this.app.vault.adapter.exists(folderName)) {
      await this.app.vault.createFolder(folderName);
      return folderName;
    }
    let i = 1;
    while (await this.app.vault.adapter.exists(`${folderName}-${i}`)) {
      i++;
    }
    const newFolderName = `${folderName}-${i}`;
    await this.app.vault.createFolder(newFolderName);
    return newFolderName;
  }
  /**
   * Iterates through the rendered HTML and replaces all image links with Base64 data.
   * This ensures the resulting HTML file works offline.
   */
  async processImages(container) {
    var _a;
    const embeds = Array.from(container.querySelectorAll("span.internal-embed"));
    for (const span of embeds) {
      const src = span.getAttribute("src");
      if (!src) continue;
      const ext = (_a = src.split(".").pop()) == null ? void 0 : _a.toLowerCase();
      const imageExtensions = ["png", "jpg", "jpeg", "gif", "bmp", "svg", "webp", "heic"];
      if (ext && imageExtensions.includes(ext)) {
        const img = document.createElement("img");
        img.setAttribute("src", src);
        img.setAttribute("data-is-embed", "true");
        img.style.maxWidth = "100%";
        span.replaceWith(img);
      }
    }
    const images = Array.from(container.querySelectorAll("img"));
    const promises = images.map(async (img, index) => {
      await this.embedSingleImage(img, index);
    });
    await Promise.all(promises);
  }
  /**
   * Processes a single image element: resolves source, fetches data, and converts to Base64.
   */
  async embedSingleImage(img, index) {
    const originalSrc = img.getAttribute("src");
    if (!originalSrc || originalSrc.startsWith("data:")) return;
    try {
      const isEmbed = img.getAttribute("data-is-embed") === "true";
      let linktext = "";
      if (isEmbed) {
        linktext = originalSrc;
      } else {
        const decodedSrc = decodeURIComponent(originalSrc);
        linktext = decodedSrc.split("?")[0];
        linktext = linktext.split("/").pop() || "";
      }
      let buffer = null;
      let mimeType = "image/png";
      const activeFile = this.app.workspace.getActiveFile();
      let file = this.app.metadataCache.getFirstLinkpathDest(linktext, (activeFile == null ? void 0 : activeFile.path) || "");
      if (!file && linktext) {
        const found = this.app.vault.getFiles().find((f) => f.name === linktext);
        file = found || null;
      }
      if (file) {
        if (false) console.log(`[AndroidPdf] Found local file: ${file.path}`);
        buffer = await this.app.vault.readBinary(file);
        mimeType = this.getMimeType(file.extension);
      } else if (!isEmbed && originalSrc.startsWith("http")) {
        if (false) console.log(`[AndroidPdf] Fetching remote: ${originalSrc}`);
        const response = await (0, import_obsidian.requestUrl)({ url: originalSrc });
        buffer = response.arrayBuffer;
        mimeType = response.headers["content-type"] || "image/png";
      }
      if (buffer) {
        const base64 = await this.arrayBufferToBase64Async(buffer, mimeType);
        img.setAttribute("src", base64);
        img.removeAttribute("srcset");
        img.removeAttribute("data-src");
        img.removeAttribute("data-is-embed");
        img.removeAttribute("sizes");
      } else {
        console.warn(`[AndroidPdf] Could not resolve image: ${originalSrc}`);
        img.alt = `[Image Missing: ${originalSrc}]`;
        img.style.border = "1px solid red";
      }
    } catch (err) {
      console.error(`[AndroidPdf] Failed to process image ${originalSrc}`, err);
    }
  }
  /**
   * Helper to map extensions to MimeTypes.
   */
  getMimeType(extension) {
    switch (extension.toLowerCase()) {
      case "jpg":
      case "jpeg":
        return "image/jpeg";
      case "webp":
        return "image/webp";
      case "gif":
        return "image/gif";
      case "svg":
        return "image/svg+xml";
      case "bmp":
        return "image/bmp";
      default:
        return "image/png";
    }
  }
  /**
   * Helper to read ArrayBuffer to Base64 String using FileReader.
   */
  async arrayBufferToBase64Async(buffer, mimeType) {
    return new Promise((resolve, reject) => {
      const blob = new Blob([buffer], { type: mimeType });
      const reader = new FileReader();
      reader.onloadend = () => {
        if (reader.result) {
          resolve(reader.result);
        } else {
          reject(new Error("Empty conversion result"));
        }
      };
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  /**
   * Removes unsupported elements for print (video, audio, etc).
   */
  sanitizeElements(container) {
    container.querySelectorAll("video, audio, iframe").forEach((el) => {
      const placeholder = document.createElement("div");
      placeholder.innerText = `[Media/Embed not supported in PDF Export]`;
      placeholder.style.border = "1px dashed #ccc";
      placeholder.style.padding = "10px";
      placeholder.style.color = "#888";
      placeholder.style.textAlign = "center";
      el.replaceWith(placeholder);
    });
  }
  /**
   * Wraps the content in a full HTML document structure.
   */
  generateHtmlTemplate(title, contentHtml) {
    return `
<!DOCTYPE html>
<html>
<head>
    <title>${title}</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    ${this.styles}
</head>
<body>
    ${contentHtml}
    <script>
        // Auto-trigger print when opened
        window.onload = function() {
            setTimeout(function() {
                window.print();
            }, 500);
        }
    <\/script>
</body>
</html>`;
  }
  /**
   * Saves the HTML file and opens the feedback modal.
   */
  async saveAndPrompt(basename, folderName, fullHtml) {
    if (false) console.log("[AndroidPdf] Saving to vault...");
    const buffer = new TextEncoder().encode(fullHtml).buffer;
    const htmlPath = `${folderName}/index.html`;
    await this.app.vault.createBinary(htmlPath, buffer);
    new import_obsidian.Notice(`Exported to: ${folderName}`);
    new OpenPdfModal(this.app, htmlPath).open();
  }
};
var OpenPdfModal = class extends import_obsidian.Modal {
  constructor(app, filePath) {
    super(app);
    this.filePath = filePath;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "PDF Export Ready" });
    contentEl.createEl("p", { text: `HTML file generated at: ${this.filePath}` });
    contentEl.createEl("p", { text: "Open this file in your browser to print it as a PDF." });
    const div = contentEl.createDiv({ cls: "modal-button-container" });
    const btnOpen = div.createEl("button", { text: "Open in Browser", cls: "mod-cta" });
    btnOpen.addEventListener("click", () => {
      this.app.openWithDefaultApp(this.filePath);
      this.close();
    });
    const btnCancel = div.createEl("button", { text: "Done" });
    btnCancel.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};
